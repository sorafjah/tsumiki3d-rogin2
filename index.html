<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>3Dブロック積み木アプリ (ログイン機能付き)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.163.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.163.0/examples/jsm/"
            }
        }
    </script>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Inter', sans-serif; background-color: #f0f8ff; }
        #container { width: 100vw; height: 100vh; display: block; }
        /* .controls のスタイルを変更 */
        .controls { 
            position: absolute; 
            bottom: 30px; /* 少し上に移動 */
            left: 50%; 
            transform: translateX(-50%); 
            display: flex; 
            flex-wrap: nowrap; /* ボタンが折り返さないように変更 */
            justify-content: center; 
            gap: 8px; /* ボタン間の間隔を狭める */
            padding: 10px; 
            background-color: rgba(255,255,255,0.85); 
            border-radius: 8px; 
            box-shadow: 0 2px 10px rgba(0,0,0,0.2); 
            z-index: 10;
        }
        .color-palette { position: absolute; top: 20px; left: 20px; display: flex; flex-direction: column; gap: 8px; padding: 10px; background-color: rgba(255,255,255,0.85); border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.2); z-index: 10; }
        .color-button { width: 30px; height: 30px; border-radius: 50%; border: 2px solid white; cursor: pointer; box-shadow: 0 1px 3px rgba(0,0,0,0.3); transition: transform 0.2s, border-color 0.2s; }
        .color-button.selected { border-color: #3b82f6; transform: scale(1.15); }
        /* .action-button のパディングを変更 */
        .action-button { 
            padding: 8px 12px; /* パディングを減らす */
            background-color: #3b82f6; 
            color: white; 
            border: none; 
            border-radius: 6px; 
            cursor: pointer; 
            font-size: 16px; 
            transition: background-color 0.3s; 
            box-shadow: 0 1px 3px rgba(0,0,0,0.2); 
            white-space: nowrap; /* ボタン内のテキストが折り返さないように */
        }
        .action-button:hover { background-color: #2563eb; }
        .action-button.orange { background-color: #f97316; }
        .action-button.orange:hover { background-color: #ea580c; }
        
        /* 操作パネルの位置を調整 */
        #block-controls-panel { 
            position: absolute; 
            bottom: 110px; /* さらに上に移動 */ 
            right: 20px; 
            background-color: rgba(255,255,255,0.85); 
            border-radius: 8px; 
            padding:10px; 
            box-shadow: 0 2px 10px rgba(0,0,0,0.2); 
            display: grid; 
            grid-template-areas: ". up ." "left . right" ". down ." "y-up y-up y-up" "y-down y-down y-down"; 
            grid-template-columns: repeat(3, 1fr); 
            gap: 5px; 
            width: 160px; 
            z-index: 10; 
        }

        .move-block-button { background-color: #60a5fa; color:white; border:none; border-radius:5px; width:100%; height:35px; display:flex; justify-content:center; align-items:center; cursor:pointer; font-size: 18px; transition: background-color 0.3s; }
        .move-block-button:hover { background-color: #3b82f6; }
        #move-z-plus { grid-area: up; }
        #move-x-minus { grid-area: left; }
        #move-x-plus { grid-area: right; }
        #move-z-minus { grid-area: down; }
        #move-y-plus { grid-area: y-up; margin-top: 5px;}
        #move-y-minus { grid-area: y-down; margin-top: 5px;}

        #instructionText { position: absolute; top: 20px; right: 20px; padding: 8px 12px; background-color: rgba(255,255,255,0.8); color: #333; border-radius: 5px; font-size: 13px; z-index: 10; text-align: right; box-shadow: 0 1px 3px rgba(0,0,0,0.1); }
        #loading-indicator { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); padding: 20px 30px; background-color: rgba(0,0,0,0.75); color: white; border-radius: 8px; font-size: 18px; z-index: 2500; display: none; box-shadow: 0 4px 15px rgba(0,0,0,0.3); }
        .custom-modal { display: none; position: fixed; z-index: 2000; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.5); align-items: center; justify-content: center; }
        .custom-modal-content { background-color: #fefefe; margin: auto; padding: 25px; border: 1px solid #bbb; width: 90%; max-width: 500px; border-radius: 10px; text-align: center; box-shadow: 0 5px 20px rgba(0,0,0,0.25); position: relative; }
        .custom-modal-close { color: #888; position: absolute; top: 10px; right: 15px; font-size: 28px; font-weight: bold; cursor: pointer; line-height: 1; }
        .custom-modal-close:hover, .custom-modal-close:focus { color: #333; text-decoration: none; }
        #customModalMessage { font-size: 16px; color: #333; margin-top: 10px; margin-bottom: 15px; }

        /* ログイン画面用のスタイル */
        #loginModal { position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background-color: rgba(0, 0, 0, 0.6); display: flex; align-items: center; justify-content: center; z-index: 3000; }
        #loginBox { background-color: white; padding: 30px 40px; border-radius: 10px; text-align: center; box-shadow: 0 5px 20px rgba(0,0,0,0.3); }
        #loginBox h3 { margin-top: 0; color: #333; }
        #nicknameInput { width: 100%; padding: 10px; margin: 15px 0; border: 1px solid #ccc; border-radius: 5px; font-size: 16px; }
        #loginButton, #anonymousButton { width: 100%; padding: 10px; border-radius: 5px; border: none; cursor: pointer; font-size: 16px; transition: background-color 0.3s; }
        #loginButton { background-color: #3b82f6; color: white; margin-bottom: 10px; }
        #loginButton:hover { background-color: #2563eb; }
        #anonymousButton { background-color: #6b7280; color: white; }
        #anonymousButton:hover { background-color: #4b5563; }
        #logoutButton { display: none; }
        
        /* ログイン中表示の位置を調整 */
        #userInfo {
            position: absolute;
            top: 90px;
            right: 20px;
            background: rgba(255, 255, 255, 0.8);
            padding: 8px 12px;
            border-radius: 5px;
            font-size: 13px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            color: #333;
            display: none;
            text-align: right;
        }

        #saveModal .save-new-section { margin: 20px 0; display: flex; gap: 10px; align-items: center; justify-content: center; flex-wrap: wrap;}
        #saveModal input[type="text"] { padding: 8px 12px; border: 1px solid #ccc; border-radius: 4px; font-size: 16px; flex-grow: 1; min-width: 180px; }
        #saveModal button { padding: 8px 15px; border-radius: 4px; border: none; cursor: pointer; font-size: 16px; transition: background-color 0.3s; }
        #saveNewButton { background-color: #10b981; color: white; }
        #saveNewButton:hover { background-color: #059669; }
        #savedStatesList { margin-top: 20px; max-height: 40vh; overflow-y: auto; text-align: left; border-top: 1px solid #eee; padding-top: 10px; }
        .saved-item { display: flex; justify-content: space-between; align-items: center; padding: 12px; border-bottom: 1px solid #eee; gap: 10px; }
        .saved-item-name { font-weight: bold; flex-grow: 1; }
        .saved-item-date { font-size: 12px; color: #666; }
        .saved-item-actions button { font-size: 14px; margin-left: 5px; }
        .load-button { background-color: #3b82f6; color: white; }
        .load-button:hover { background-color: #2563eb; }
        .delete-save-button { background-color: #f97316; color: white; }
        .delete-save-button:hover { background-color: #ea580c; }

        #confirmModal .custom-modal-content { max-width: 350px; }
        .confirm-actions { margin-top: 20px; display: flex; justify-content: center; gap: 15px; }
    </style>
</head>
<body>
    <div id="loginModal">
        <div id="loginBox">
            <h3>ニックネームでログイン</h3>
            <p style="font-size:14px; color:#555;">他のデバイスと作品を共有できます</p>
            <input type="text" id="nicknameInput" placeholder="ニックネームを入力">
            <button id="loginButton">この名前で始める</button>
            <button id="anonymousButton">ログインせずに続ける</button>
        </div>
    </div>

    <div id="container"></div>
    <div id="loading-indicator">処理中...</div>

    <div id="instructionText">タップで選択<br>ダブルタップで作成</div>
    <div id="userInfo"></div>
    
    <div class="controls">
        <button id="saveLoadButton" class="action-button">保存/読込</button>
        <button id="deleteButton" class="action-button">削除</button>
        <button id="fixViewButton" class="action-button">視点固定</button>
        <button id="toggleEdgesButton" class="action-button">辺を表示</button> 
        <button id="logoutButton" class="action-button">ログアウト</button>
    </div>

    <div class="color-palette"></div>

    <div id="block-controls-panel">
        <button id="move-z-plus" class="move-block-button" data-axis="z" data-dir="1" title="奥へ移動">▲</button>
        <button id="move-x-minus" class="move-block-button" data-axis="x" data-dir="-1" title="左へ移動">◀</button>
        <button id="move-x-plus" class="move-block-button" data-axis="x" data-dir="1" title="右へ移動">▶</button>
        <button id="move-z-minus" class="move-block-button" data-axis="z" data-dir="-1" title="手前へ移動">▼</button>
        <button id="move-y-plus" class="move-block-button" data-axis="y" data-dir="1" title="上へ移動">上へ</button>
        <button id="move-y-minus" class="move-block-button" data-axis="y" data-dir="-1" title="下へ移動">下へ</button>
    </div>

    <div id="customModal" class="custom-modal"><div class="custom-modal-content"><span id="customModalClose" class="custom-modal-close" title="閉じる">&times;</span><p id="customModalMessage"></p></div></div>
    <div id="saveModal" class="custom-modal"><div class="custom-modal-content"><span id="saveModalClose" class="custom-modal-close" title="閉じる">&times;</span><h3>保存と読込</h3><div class="save-new-section"><input type="text" id="saveNameInput" placeholder="作品名 (例: はじめての城)"><button id="saveNewButton">現在の状態で新規保存</button></div><div id="savedStatesList"><p>保存した作品はありません。</p></div></div></div>
    <div id="confirmModal" class="custom-modal"><div class="custom-modal-content"><p id="confirmModalMessage"></p><div class="confirm-actions"><button id="confirmYesButton" class="action-button">はい</button><button id="confirmNoButton" class="action-button orange">いいえ</button></div></div></div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, getDoc, collection, addDoc, getDocs, deleteDoc, onSnapshot, query, serverTimestamp, writeBatch } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Firebaseのログは通常は不要なのでコメントアウト
        // import { setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        // setLogLevel('debug');

        const firebaseConfig = {
          apiKey: "AIzaSyBk-lnmwZnhPTj3yQuMfRBc3u5HFXko95k",
          authDomain: "tsumiki3d.firebaseapp.com",
          projectId: "tsumiki3d",
          storageBucket: "tsumiki3d.firebasestorage.app",
          messagingSenderId: "245181141529",
          appId: "1:245181141529:web:a95fa288ab74de8ceb5088"
        };
        
        const appId = firebaseConfig.appId;
        
        let app, auth, db, userId, currentNickname = null;
        let cubesCollectionRef, savesCollectionRef;
        let isAuthReady = false;
        let unsubscribeFromCubes = null;

        const loadingIndicator = document.getElementById('loading-indicator');
        const customModal = document.getElementById('customModal');
        const customModalMessage = document.getElementById('customModalMessage');
        const customModalClose = document.getElementById('customModalClose');
        const saveModal = document.getElementById('saveModal');
        const saveModalClose = document.getElementById('saveModalClose');
        const confirmModal = document.getElementById('confirmModal');
        const confirmModalMessage = document.getElementById('confirmModalMessage');
        const confirmYesButton = document.getElementById('confirmYesButton');
        const confirmNoButton = document.getElementById('confirmNoButton');
        
        const loginModal = document.getElementById('loginModal');
        const nicknameInput = document.getElementById('nicknameInput');
        const loginButton = document.getElementById('loginButton');
        const anonymousButton = document.getElementById('anonymousButton');
        const logoutButton = document.getElementById('logoutButton');
        const userInfo = document.getElementById('userInfo');
        
        if (customModalClose) customModalClose.onclick = () => customModal.style.display = "none";
        if (saveModalClose) saveModalClose.onclick = () => saveModal.style.display = "none";
        window.onclick = event => { 
            if (event.target == customModal) customModal.style.display = "none";
            if (event.target == saveModal) saveModal.style.display = "none";
            if (event.target == confirmModal) confirmModal.style.display = "none";
        }

        function showUserMessage(message) {
            console.warn("UserMessage:", message); // コンソールにも出力
            if (customModal && customModalMessage) {
                customModalMessage.textContent = message;
                customModal.style.display = "flex";
            }
        }

        function showConfirmation(message, onConfirm) {
            confirmModalMessage.textContent = message;
            confirmModal.style.display = 'flex';
            confirmYesButton.onclick = () => {
                confirmModal.style.display = 'none';
                onConfirm();
            };
            confirmNoButton.onclick = () => {
                confirmModal.style.display = 'none';
                // No action needed for 'No'
            };
        }
        
        async function initializeFirebase() {
            try {
                app = initializeApp(firebaseConfig);
                auth = getAuth(app);
                db = getFirestore(app);
                
                return new Promise((resolve, reject) => {
                    onAuthStateChanged(auth, async (user) => {
                        if (user) {
                            userId = user.uid;
                        } else {
                            try {
                                // 匿名ログインを試みる（初回起動時など）
                                await signInAnonymously(auth);
                                userId = auth.currentUser.uid;
                            } catch (error) {
                                reject(error);
                                return;
                            }
                        }

                        if (!userId) {
                            reject(new Error("ユーザーIDの取得に失敗しました。"));
                            return;
                        }
                        
                        // ニックネームが設定されている場合はニックネームベースのパス、
                        // そうでなければ匿名ユーザーIDベースのパスを使用
                        if (currentNickname) {
                            // Firestoreのパスで使用できない文字をアンダースコアに置換
                            const sanitizedNickname = currentNickname.replace(/[\.#$\[\]]/g, '_');
                            const nicknamePath = `artifacts/${appId}/nicknames/${sanitizedNickname}`;
                            cubesCollectionRef = collection(db, `${nicknamePath}/cubes`);
                            savesCollectionRef = collection(db, `${nicknamePath}/saves`);
                            userInfo.textContent = `ログイン中: ${currentNickname}`;
                            userInfo.style.display = 'block';
                            logoutButton.style.display = 'block';
                        } else {
                            const userPath = `artifacts/${appId}/users/${userId}`; // 匿名ユーザーはユーザーIDベース
                            cubesCollectionRef = collection(db, `${userPath}/cubes`);
                            savesCollectionRef = collection(db, `${userPath}/saves`);
                            userInfo.textContent = 'オフラインモード';
                            userInfo.style.display = 'block';
                            logoutButton.style.display = 'none'; // 匿名ログイン時はログアウトボタンを非表示
                        }

                        isAuthReady = true; 
                        resolve(); 
                    });
                });
            } catch (error) {
                console.error("Firebase initialization error:", error);
                showUserMessage("アプリの起動に失敗しました: " + error.message); 
                return Promise.reject(error);
            }
        }

        let scene, camera, renderer, orbitControls;
        let plane;
        const cubes = []; // Three.jsのキューブオブジェクトの配列
        let selectedCube = null; // 選択中のキューブ
        let areEdgesVisible = false; // キューブの辺の表示状態

        // カラーパレットの定義
        const userImageColors = [ { name: '明るい紫', hex: 0xB080FF }, { name: 'さらに明るい赤', hex: 0xFF7F7F }, { name: '黄', hex: 0xFFFF00 }, { name: '明るい緑', hex: 0x90EE90 }, { name: '明るい青', hex: 0x6495ED }, { name: '白', hex: 0xFFFFFF }, { name: 'グレー', hex: 0xB0B0B0 }, { name: '明るい茶', hex: 0xDEB887 }, { name: 'ピンク', hex: 0xFFC0CB }, { name: 'オレンジ', hex: 0xFFA500 }, { name: '黄緑', hex: 0x9ACD32 }, { name: '青みがかった明るい水色', hex: 0xAFEEEE } ];
        let currentHexColor = userImageColors[userImageColors.length - 1].hex; // 現在選択中の色（初期値はパレットの最後の色）

        const raycaster = new THREE.Raycaster();
        const pointer = new THREE.Vector2();
        const cubeSize = 1; // キューブの一辺の長さ
        const cubeGeometry = new THREE.BoxGeometry(cubeSize, cubeSize, cubeSize); // ★キューブのジオメトリ (共有)

        let lastTouchTime = 0; // タッチイベントのタイムスタンプ
        const DOUBLE_TAP_TIMEOUT = 300; // ダブルタップと認識する時間間隔（ミリ秒）
        let touchStartPointer = { x: 0, y: 0 }; // タッチ開始時の座標
        const MAX_TAP_MOVE_THRESHOLD = 20; // タップと認識する移動のしきい値（ピクセル）

        function initThreeJS() {
            const container = document.getElementById('container');
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xF0F8FF); // 背景色

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(5, 5, 5); // カメラの初期位置
            camera.lookAt(0, 0, 0); // カメラの視点

            renderer = new THREE.WebGLRenderer({ antialias: true }); // WebGLレンダラー
            renderer.setSize(window.innerWidth, window.innerHeight); // レンダラーのサイズ
            renderer.shadowMap.enabled = true; // 影の有効化
            container.appendChild(renderer.domElement); // DOMに追加

            // 環境光と指向性ライト
            scene.add(new THREE.AmbientLight(0xffffff, 0.9));
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
            directionalLight.position.set(5, 10, 7.5);
            directionalLight.castShadow = true;
            scene.add(directionalLight);

            // 地面（平面）
            const planeGeometry = new THREE.PlaneGeometry(50, 50);
            const planeMaterial = new THREE.MeshStandardMaterial({ color: 0x98FB98, side: THREE.DoubleSide });
            plane = new THREE.Mesh(planeGeometry, planeMaterial);
            plane.rotation.x = -Math.PI / 2; // X軸を中心に-90度回転
            plane.receiveShadow = true;
            scene.add(plane);

            // 座標軸の描画 (参考用)
            const lineMaterial = new THREE.LineBasicMaterial({ color: 0x888888 });
            const lineLength = 25; 
            
            const pointsX = [];
            pointsX.push(new THREE.Vector3(-lineLength, 0.01, 0));
            pointsX.push(new THREE.Vector3( lineLength, 0.01, 0));
            const geometryX = new THREE.BufferGeometry().setFromPoints(pointsX);
            const xAxisLine = new THREE.Line(geometryX, lineMaterial);
            scene.add(xAxisLine);

            const pointsZ = [];
            pointsZ.push(new THREE.Vector3(0, 0.01, -lineLength));
            pointsZ.push(new THREE.Vector3(0, 0.01,  lineLength));
            const geometryZ = new THREE.BufferGeometry().setFromPoints(pointsZ);
            const zAxisLine = new THREE.Line(geometryZ, lineMaterial);
            scene.add(zAxisLine);

            // カメラコントロール
            orbitControls = new OrbitControls(camera, renderer.domElement);
            orbitControls.enableDamping = true; // 慣性有効化
            orbitControls.target.set(0, cubeSize / 2, 0); // 視点の中心

            // イベントリスナー設定
            window.addEventListener('resize', onWindowResize);
            renderer.domElement.addEventListener('pointerdown', onPointerDown, false);
            renderer.domElement.addEventListener('click', onCanvasClick, false);
            renderer.domElement.addEventListener('dblclick', onCanvasDblClick, false);
            renderer.domElement.addEventListener('touchend', onCanvasTouchEnd, false);
            document.getElementById('saveLoadButton').addEventListener('click', openSavePanel);
            document.getElementById('saveNewButton').addEventListener('click', saveCurrentState);
            document.getElementById('deleteButton').addEventListener('click', deleteSelectedCube);
            document.getElementById('fixViewButton').addEventListener('click', toggleViewpointFix);
            document.getElementById('toggleEdgesButton').addEventListener('click', toggleCubeEdgesVisibility);
            
            setupColorPalette(); // カラーパレットのセットアップ
            setupBlockControls(); // ブロック操作ボタンのセットアップ
            animate(); // アニメーションループ開始
        }
        
        // 保存・読込パネルを開く
        async function openSavePanel() {
            if (!isAuthReady) { showUserMessage("データベースの準備ができていません。"); return; }
            if (!currentNickname) { showUserMessage("作品を保存・読込するにはニックネームでのログインが必要です。"); return; }
            const savedStatesList = document.getElementById('savedStatesList');
            saveModal.style.display = 'flex';
            savedStatesList.innerHTML = '<p>読込中...</p>';
            try {
                // 保存された作品リストを取得し、作成日時でソート
                const querySnapshot = await getDocs(query(savesCollectionRef));
                if (querySnapshot.empty) {
                    savedStatesList.innerHTML = '<p>保存した作品はありません。</p>';
                    return;
                }
                savedStatesList.innerHTML = '';
                const saves = [];
                querySnapshot.forEach(doc => saves.push({ id: doc.id, ...doc.data() }));
                saves.sort((a, b) => (b.createdAt?.toMillis() || 0) - (a.createdAt?.toMillis() || 0)); // 最新のものが上に来るようにソート

                // リスト表示
                saves.forEach(data => {
                    const itemDiv = document.createElement('div');
                    itemDiv.className = 'saved-item';
                    itemDiv.innerHTML = `
                        <span class="saved-item-name">${data.name || '無題の作品'}</span>
                        <span class="saved-item-date">${data.createdAt ? new Date(data.createdAt.toMillis()).toLocaleString() : '日付不明'}</span>
                        <div class="saved-item-actions">
                            <button class="load-button" data-id="${data.id}">読込</button>
                            <button class="delete-save-button" data-id="${data.id}" data-name="${data.name || '無題の作品'}">削除</button>
                        </div>`;
                    savedStatesList.appendChild(itemDiv);
                });
                // 各ボタンにイベントリスナーを設定
                savedStatesList.querySelectorAll('.load-button').forEach(b => b.addEventListener('click', (e) => loadState(e.target.dataset.id)));
                savedStatesList.querySelectorAll('.delete-save-button').forEach(b => b.addEventListener('click', (e) => deleteState(e.target.dataset.id, e.target.dataset.name)));
            } catch (error) {
                console.error("Error fetching saved states:", error);
                showUserMessage("作品リストの読込に失敗しました。");
            }
        }
        
        // 現在の作品状態を新規保存
        async function saveCurrentState() {
            if (!currentNickname) { showUserMessage("作品を保存するにはニックネームでのログインが必要です。"); return; }
            const saveNameInput = document.getElementById('saveNameInput');
            const saveName = saveNameInput.value.trim();
            if (!saveName) { showUserMessage("作品名を入力してください。"); return; }
            if (cubes.length === 0) { showUserMessage("保存するブロックがありません。"); return; }
            loadingIndicator.style.display = 'block';
            // 現在の全キューブのデータを取得
            const cubesData = cubes.map(cube => ({
                x: cube.position.x, y: cube.position.y, z: cube.position.z,
                color: cube.material.color.getHex()
            }));
            try {
                // savesコレクションに新しい作品として追加
                await addDoc(savesCollectionRef, { name: saveName, createdAt: serverTimestamp(), cubes: cubesData });
                saveNameInput.value = ''; // 入力フィールドをクリア
                showUserMessage(`「${saveName}」を新規保存しました。`); // 成功メッセージ追加
                await openSavePanel(); // 保存後、リストを再表示
            } catch (error) {
                console.error("Error saving state:", error); 
                showUserMessage("作品の保存に失敗しました。");
            }
            finally { loadingIndicator.style.display = 'none'; }
        }
        
        // 保存された作品を読み込む
        async function loadState(saveId) {
            if (!isAuthReady) { showUserMessage("データベースの準備ができていません。"); return; }
            saveModal.style.display = 'none';
            loadingIndicator.style.display = 'block';

            // ★既存のFirebaseリスナーを解除★
            if (unsubscribeFromCubes) {
                unsubscribeFromCubes();
                unsubscribeFromCubes = null;
            }

            try {
                // 現在のcubesCollectionRefのデータを全て削除する (トランザクション処理)
                const currentCubesSnapshot = await getDocs(cubesCollectionRef);
                const deleteBatch = writeBatch(db);
                currentCubesSnapshot.forEach(d => deleteBatch.delete(d.ref));
                await deleteBatch.commit(); // 削除の実行
                
                // 保存データからcubesCollectionRefにブロックを再追加する (トランザクション処理)
                const saveDoc = await getDoc(doc(savesCollectionRef, saveId));
                if (!saveDoc.exists()) throw new Error("保存データが見つかりません。");
                const savedCubesData = saveDoc.data().cubes;
                const saveName = saveDoc.data().name;

                const addBatch = writeBatch(db);
                savedCubesData.forEach(cubeData => {
                    const newCubeRef = doc(cubesCollectionRef); // 新しいドキュメントIDを生成
                    addBatch.set(newCubeRef, cubeData); // バッチに設定を追加
                });
                await addBatch.commit(); // 追加の実行
                
                showUserMessage(`「${saveName}」を読み込みました。`);

                // ★★★ ここで再びFirebaseリスナーを開始する (重要) ★★★
                await loadCubesFromFirestore();

            } catch(error) {
                console.error("Error loading state:", error);
                showUserMessage("作品の読み込みに失敗しました: " + error.message);
            } finally {
                loadingIndicator.style.display = 'none';
            }
        }

        // 保存された作品を削除
        function deleteState(saveId, saveName) {
            showConfirmation(`「${saveName}」を本当に削除しますか？この操作は元に戻せません。`, async () => {
                loadingIndicator.style.display = 'block';
                try {
                    await deleteDoc(doc(savesCollectionRef, saveId)); // ドキュメントを削除
                    showUserMessage(`「${saveName}」を削除しました。`); 
                    await openSavePanel(); // 削除後、リストを再表示
                } catch(error) {
                    console.error("Error deleting state:", error);
                    showUserMessage("保存データの削除に失敗しました。");
                }
                finally { loadingIndicator.style.display = 'none'; }
            });
        }
        
        // カラーパレットのセットアップ
        function setupColorPalette() {
            const paletteContainer = document.querySelector('.color-palette');
            paletteContainer.innerHTML = ''; // 一度クリア
            userImageColors.forEach(color => { 
                const button = document.createElement('button');
                button.className = 'color-button';
                button.style.backgroundColor = `#${color.hex.toString(16).padStart(6, '0')}`;
                if (color.hex === currentHexColor) button.classList.add('selected'); // 初期選択状態
                button.addEventListener('click', () => {
                    currentHexColor = color.hex; // 選択された色を更新
                    // 全てのボタンの選択状態を解除し、現在のボタンを選択状態にする
                    document.querySelectorAll('.color-button').forEach(btn => btn.classList.remove('selected'));
                    button.classList.add('selected');
                    // 選択中のキューブがあれば色を変更
                    if (selectedCube) changeCubeColor(selectedCube, currentHexColor);
                });
                paletteContainer.appendChild(button);
            });
        }

        // ブロック操作ボタンのセットアップ
        function setupBlockControls() {
            document.getElementById('block-controls-panel').addEventListener('click', (e) => {
                if(e.target.classList.contains('move-block-button')) {
                    const axis = e.target.dataset.axis; // 'x', 'y', 'z'
                    const direction = parseInt(e.target.dataset.dir); // 1 or -1
                    moveSelectedBlock(axis, direction);
                }
            });
        }

        // 選択中のブロックを移動
        async function moveSelectedBlock(axis, direction) {
            if (!selectedCube) { showUserMessage("動かすブロックを選択してください。"); return; }
            const originalPosition = selectedCube.position.clone(); // 移動前の位置を保存
            const targetPosition = originalPosition.clone();
            targetPosition[axis] += direction * cubeSize; // ターゲット位置を計算

            // Y座標が地面より下にならないように調整
            if (targetPosition.y < cubeSize / 2) targetPosition.y = cubeSize / 2;

            // 他のブロックとの衝突判定
            let collision = false;
            for (const cube of cubes) {
                if (cube === selectedCube) continue; // 自身とは衝突しない
                // 厳密な判定ではなく、少し離れたら衝突とみなす (浮動小数点誤差対策)
                if (targetPosition.distanceTo(cube.position) < cubeSize * 0.99) {
                    collision = true;
                    break;
                }
            }
            if (collision) { showUserMessage("そこには動かせません（他のブロックと衝突します）。"); return; }
            
            selectedCube.position.copy(targetPosition); // Three.jsでの位置更新
            try {
                // Firebaseに位置情報を更新
                await setDoc(doc(cubesCollectionRef, selectedCube.userData.firestoreId), { x: targetPosition.x, y: targetPosition.y, z: targetPosition.z }, { merge: true });
            } catch (error) { 
                console.error("Error moving cube:", error);
                selectedCube.position.copy(originalPosition); // 失敗したら元の位置に戻す
                showUserMessage("ブロックの移動に失敗しました。");
            }
        }

        // キューブの辺の表示/非表示を切り替える
        function toggleCubeEdgesVisibility() {
            areEdgesVisible = !areEdgesVisible;
            cubes.forEach(c => { 
                if (c.userData.edges) c.userData.edges.visible = areEdgesVisible; 
            });
            document.getElementById('toggleEdgesButton').textContent = areEdgesVisible ? '辺を隠す' : '辺を表示';
        }

        // ウィンドウのリサイズ処理
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // ポインタダウンイベント（マウス/タッチ）
        function onPointerDown(event) {
            const rect = renderer.domElement.getBoundingClientRect();
            // 正規化デバイス座標を計算 (-1 to +1)
            pointer.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            pointer.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            // タッチ開始時の座標を記録 (タップ判定用)
            if (event.pointerType === 'touch') {
                touchStartPointer.x = event.clientX;
                touchStartPointer.y = event.clientY;
            }
        }

        // クリックイベント (マウス用)
        function onCanvasClick(event) { if (event.pointerType !== 'touch') onCanvasClickLogic(); }
        // ダブルクリックイベント (マウス用)
        async function onCanvasDblClick(event) { if (event.pointerType !== 'touch') onCanvasDblClickLogic(); }
        
        // タッチ終了イベント (タッチ用)
        function onCanvasTouchEnd(event) {
            const currentTime = new Date().getTime();
            const timeSinceLastTouch = currentTime - lastTouchTime;
            const touch = event.changedTouches[0]; 
            if (!touch) return; 

            const rect = renderer.domElement.getBoundingClientRect();
            // タッチ移動量を計算
            const deltaX = Math.abs(touch.clientX - touchStartPointer.x);
            const deltaY = Math.abs(touch.clientY - touchStartPointer.y);

            // 移動量が少ない場合はタップとみなす
            if (deltaX < MAX_TAP_MOVE_THRESHOLD && deltaY < MAX_TAP_MOVE_THRESHOLD) {
                event.preventDefault(); // スクロール防止
                pointer.x = ((touch.clientX - rect.left) / rect.width) * 2 - 1;
                pointer.y = -((touch.clientY - rect.top) / rect.height) * 2 + 1;

                // ダブルタップ判定
                if (timeSinceLastTouch < DOUBLE_TAP_TIMEOUT) { 
                    onCanvasDblClickLogic(); 
                    lastTouchTime = 0; // リセット
                } 
                // シングルタップ判定
                else { 
                    onCanvasClickLogic(); 
                    lastTouchTime = currentTime; 
                }
            } else { 
                lastTouchTime = 0; // 移動があった場合はタップではない
            }
        }

        // クリックロジック（ブロック選択）
        function onCanvasClickLogic() {
            raycaster.setFromCamera(pointer, camera); // レイキャストを設定
            const intersects = raycaster.intersectObjects(cubes, false); // キューブとの交差判定
            
            const clickedCube = intersects.length > 0 ? intersects[0].object : null;

            // 以前選択されていたキューブがあれば選択解除のハイライトを消す
            if (selectedCube) {
                selectedCube.material.emissive.setHex(0x000000); 
            }
            
            selectedCube = clickedCube; // 選択中のキューブを更新

            // 新しく選択されたキューブがあればハイライト
            if (selectedCube) {
                selectedCube.material.emissive.setHex(0x444444); 
            } 
        }

        // ダブルクリックロジック（ブロック作成）
        async function onCanvasDblClickLogic() {
            raycaster.setFromCamera(pointer, camera); // レイキャストを設定
            const intersects = raycaster.intersectObjects([plane, ...cubes], false); // 地面かキューブとの交差判定
            
            if (intersects.length === 0 || !intersects[0].face) return; // 交差なし、または面情報なし

            const intersect = intersects[0];
            const newPosition = new THREE.Vector3();

            // 地面をクリックした場合
            if (intersect.object === plane) { 
                newPosition.set( Math.round(intersect.point.x), cubeSize / 2, Math.round(intersect.point.z) );
            } 
            // キューブをクリックした場合
            else { 
                // クリックしたキューブの面法線方向に新しいキューブを配置
                newPosition.copy(intersect.object.position).addScaledVector(intersect.face.normal, cubeSize);
            }

            // 位置をグリッドにスナップ（整数値に丸める）
            newPosition.x = Math.round(newPosition.x);
            newPosition.y = Math.round((newPosition.y - cubeSize/2) / cubeSize) * cubeSize + cubeSize/2;
            newPosition.z = Math.round(newPosition.z);

            // Y座標が地面より下にならないように調整
            if (newPosition.y < cubeSize/2) newPosition.y = cubeSize/2;

            // 重なり判定
            let overlap = false;
            for (const cube of cubes) {
                // 厳密な判定ではなく、少し重なったらオーバーラップとみなす
                if (newPosition.distanceTo(cube.position) < 0.99) { 
                    overlap = true; 
                    break; 
                }
            }

            if (!overlap) {
                try {
                    // Firebaseに新しいブロックデータを追加
                    await addDoc(cubesCollectionRef, { x: newPosition.x, y: newPosition.y, z: newPosition.z, color: currentHexColor });
                } catch (e) { 
                    console.error("Error adding block:", e);
                    showUserMessage("ブロックの追加に失敗しました。"); 
                }
            } else { 
                showUserMessage("ここにはブロックを置けません。"); 
            }
        }
        
        // Three.jsのキューブメッシュを作成または更新
        function createCubeMesh(position, hexColor, docId) {
            // 同じFirestore IDを持つ既存のキューブを探す
            const existingCube = cubes.find(c => c.userData.firestoreId === docId);

            if (existingCube) {
                // 既に存在する場合は位置と色を更新
                existingCube.position.copy(position);
                existingCube.material.color.setHex(hexColor);
                return existingCube;
            }

            // 新しいキューブを作成 (ジオメトリは共有、マテリアルは新規作成)
            const cube = new THREE.Mesh(cubeGeometry, new THREE.MeshStandardMaterial({ color: hexColor }));
            cube.position.copy(position);
            cube.castShadow = true;
            cube.receiveShadow = true;
            cube.userData.firestoreId = docId; // FirestoreのドキュメントIDを保存

            // 辺の描画 (ジオメトリもマテリアルも新規作成)
            const edges = new THREE.LineSegments(new THREE.EdgesGeometry(cubeGeometry), new THREE.LineBasicMaterial({ color: 0x333333 }));
            edges.visible = areEdgesVisible; // 現在の辺の表示設定を適用
            cube.add(edges); // キューブの子として辺を追加
            cube.userData.edges = edges; // 辺のメッシュをUserDataに保存

            cubes.push(cube); // キューブ配列に追加
            scene.add(cube); // シーンに追加
            return cube;
        }

        // 選択中のキューブを削除
        async function deleteSelectedCube() {
            if (!selectedCube || !selectedCube.userData.firestoreId) { showUserMessage("削除するブロックを選択してください。"); return; }
            
            const cubeIdToDelete = selectedCube.userData.firestoreId; // 削除対象のIDを保持

            // 削除前に選択状態を解除し、selectedCubeをクリア
            selectedCube.material.emissive.setHex(0x000000); 
            selectedCube = null;

            try { 
                await deleteDoc(doc(cubesCollectionRef, cubeIdToDelete)); // Firebaseから削除
            } 
            catch (e) { 
                console.error("Error deleting cube:", e);
                showUserMessage("キューブの削除に失敗しました。"); 
            }
        }

        // キューブの色を変更
        async function changeCubeColor(cube, newHexColor) {
            if (!cube || !cube.userData.firestoreId) return;
            const originalColor = cube.material.color.getHex(); // 元の色を保存

            cube.material.color.setHex(newHexColor); // Three.jsでの色変更
            try { 
                // Firebaseに色情報を更新
                await setDoc(doc(cubesCollectionRef, cube.userData.firestoreId), { color: newHexColor }, { merge: true }); 
            } 
            catch (e) { 
                console.error("Error updating color:", e);
                cube.material.color.setHex(originalColor); // 失敗したら元に戻す
                showUserMessage("色の更新に失敗しました。"); 
            }
        }

        // 視点固定の切り替え
        function toggleViewpointFix() {
            orbitControls.enabled = !orbitControls.enabled; // コントロールの有効/無効を切り替え
            const button = document.getElementById('fixViewButton');
            button.textContent = orbitControls.enabled ? '視点固定' : '固定解除';
            button.classList.toggle('orange', !orbitControls.enabled); // ボタンのスタイル変更
        }

        // アニメーションループ
        function animate() {
            requestAnimationFrame(animate); // 次のフレームを要求
            if (orbitControls.enabled) orbitControls.update(); // コントロールが有効なら更新
            renderer.render(scene, camera); // シーンをレンダリング
        }

        // Firebaseからキューブデータを読み込み、リアルタイム同期を設定
        async function loadCubesFromFirestore() {
            if (!isAuthReady) return;
            loadingIndicator.style.display = 'block';

            // 既存のリスナーがあれば解除 (重要: 二重購読を防ぐ)
            if (unsubscribeFromCubes) {
                unsubscribeFromCubes();
                unsubscribeFromCubes = null;
            }
            
            // 【修正箇所①】シーンから既存のキューブを全て削除し、配列と選択状態をクリア
            while(cubes.length > 0) {
                const cube = cubes.pop();
                scene.remove(cube);

                // 輪郭線(edges)のジオメトリとマテリアルを解放
                if (cube.userData.edges) {
                    if (cube.userData.edges.geometry) {
                        cube.userData.edges.geometry.dispose();
                    }
                    if (cube.userData.edges.material) {
                        cube.userData.edges.material.dispose();
                    }
                }

                // キューブ自身のマテリアルを解放 (ジオメトリは共有なので解放しない)
                if (cube.material) {
                    cube.material.dispose();
                }
            }
            selectedCube = null; // 選択中のキューブもクリア

            // FirestoreのcubesCollectionRefのリアルタイムリスナーを設定
            unsubscribeFromCubes = onSnapshot(query(cubesCollectionRef), (snapshot) => {
                snapshot.docChanges().forEach((change) => {
                    const data = change.doc.data();
                    const docId = change.doc.id;

                    if (change.type === "added") {
                        // データが有効か確認
                        if(typeof data.x === 'number' && typeof data.y === 'number' && typeof data.z === 'number' && typeof data.color === 'number') {
                            createCubeMesh(new THREE.Vector3(data.x,data.y,data.z), data.color, docId);
                        }
                    } else if (change.type === "modified") {
                        // 変更されたキューブを探して更新
                        const c = cubes.find(c => c.userData.firestoreId === docId);
                        if (c) { 
                            c.position.set(data.x,data.y,data.z); 
                            c.material.color.setHex(data.color);
                            // 選択状態のキューブが変更された場合、ハイライトを再適用
                            if (c === selectedCube) {
                                c.material.emissive.setHex(0x444444);
                            }
                        }
                    } else if (change.type === "removed") {
                        // 【修正箇所②】削除されたキューブを探して削除
                        const i = cubes.findIndex(c => c.userData.firestoreId === docId);
                        if (i > -1) { 
                            const cubeToRemove = cubes[i];
                            // 削除されたキューブが選択中だった場合、選択状態を解除
                            if (selectedCube === cubeToRemove) {
                                selectedCube.material.emissive.setHex(0x000000); 
                                selectedCube = null;
                            }
                            scene.remove(cubeToRemove); // シーンから削除

                            // 輪郭線(edges)のジオメトリとマテリアルを解放
                            if (cubeToRemove.userData.edges) {
                                if (cubeToRemove.userData.edges.geometry) {
                                    cubeToRemove.userData.edges.geometry.dispose();
                                }
                                if (cubeToRemove.userData.edges.material) {
                                    cubeToRemove.userData.edges.material.dispose();
                                }
                            }
                            // キューブ自身のマテリアルを解放 (ジオメトリは共有なので解放しない)
                            if (cubeToRemove.material) {
                                cubeToRemove.material.dispose();
                            }
                            cubes.splice(i, 1); // 配列から削除
                        }
                    }
                });
                loadingIndicator.style.display = 'none'; // ロードインジケーターを非表示
            }, (error) => {
                // エラーハンドリング
                console.error("Error syncing data:", error);
                showUserMessage("データの同期に失敗しました。");
                loadingIndicator.style.display = 'none';
            });
        }
        
        // アプリ起動処理
        async function startApp() {
            loadingIndicator.style.display = 'block';
            try {
                await initializeFirebase(); // Firebase初期化
                initThreeJS(); // Three.js初期化
                await loadCubesFromFirestore(); // 初期キューブデータ読み込み
            } catch (error) {
                console.error("App startup error:", error); 
                showUserMessage("アプリの起動処理でエラーが発生しました: " + error.message);
                loadingIndicator.style.display = 'none';
            }
        }
        
        // メイン処理 (ログイン制御)
        function main() {
            loginButton.addEventListener('click', () => {
                const nickname = nicknameInput.value.trim();
                if (nickname) {
                    currentNickname = nickname;
                    localStorage.setItem('tsumiki_nickname', nickname); // ニックネームを保存
                    loginModal.style.display = 'none'; // ログイン画面を非表示
                    startApp(); // アプリ開始
                } else {
                    showUserMessage("ニックネームを入力してください。");
                }
            });

            anonymousButton.addEventListener('click', () => {
                currentNickname = null; // 匿名モード
                localStorage.removeItem('tsumiki_nickname'); // 匿名ログイン時はニックネームを削除
                loginModal.style.display = 'none';
                startApp();
            });

            logoutButton.addEventListener('click', () => {
                localStorage.removeItem('tsumiki_nickname'); // ニックネームをクリア
                location.reload(); // ページをリロードしてログイン画面に戻る
            });

            // 以前保存されたニックネームがあれば自動ログイン
            const savedNickname = localStorage.getItem('tsumiki_nickname');
            if (savedNickname) {
                currentNickname = savedNickname;
                loginModal.style.display = 'none';
                startApp();
            } else {
                loginModal.style.display = 'flex'; // ログイン画面を表示
            }
        }
        
        main(); // アプリケーション開始
    </script>
</body>
</html>
